# promise

## then resolve
Promise的构造函数接收一个参数，是函数，并且传入两个参数： `resolve` ， `reject` ，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的`回调函数`
> 按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected

> `new` 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数

比如：
```javascript
function runAsync() {
    var p = new Promise(function (resolve, reject) {
        let data = "一些数据";
        //做一些异步操作
        setTimeout(function () {
            console.log('执行完成');
            resolve(data);
        }, 2000);
    });
    return p;
}
runAsync().then(data => {
 console.log(data);
})

```

> `Promise` 的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用

> 在 `then` 方法中，你也可以直接 `return` 数据而不是 `Promise` 对象，在后面的 `then` 中就可以接收到数据了

## reject
```javascript
function getNumber(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
        }, 2000);
    });
    return p;            
}

getNumber()
.then(
    function(data){
        console.log('resolved');
        console.log(data);
    }, 
    function(reason, data){
        console.log('rejected');
        console.log(reason);
    }
);
```

## catch
和 `then` 的第二个参数一样，用来指定 `reject` 的回调

不在执行 `resolve` 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常，那么并不会报错卡死js，而是会进到这个 `catch` 方法中

## all

`all` 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调

`all` 接收一个数组参数，里面的值最终都算返回 `Promise` 对象

`all` 会把所有异步操作的结果放进一个数组中传给 `then`

```js
Promise
.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
```

## race
> `all` 方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是 `race` 方法
```javascript
Promise
.race([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
```
可以用 `race` 给某个异步请求设置超时时间，并且在超时后执行相应的操作
```javascript
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = 'xxxxxx';
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
```


# class
在 class 中。同时具有 `__proto__` 和 `prototype` 两个属性，存在两条继承链。

子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类。

子类的 prototype 的 `__proto__` 属性表示方法的继承，总是指向父类的 `prototype` 属性。