# promise

首先，无法取消 `Promise` ，一旦新建则立刻执行，无法中途取消，**如果不设置回调函数，则 `Promise`内部抛出的错误就不会反应到外部**

Promise 的构造函数接收一个函数作为参数，这个函数有两个参数（同样是函数）： `resolve` ， `reject` ，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的`回调函数`

## then resolve

`Promise`实例生成以后，可以使用 `then` 方法来指定 `Resolve`（即从 `Pending` 状态变为 `Fullfiled`状态）和 `Rejected`（`Pending` -> `Rejected`）状态时的函数，其中， `Rejected` 是可选的

**`Promise`新建后会立刻执行， `then` 方法指定的回调函数将在所有同步任务执行完以后才执行**

比如：

```javascript
function runAsync() {
  var p = new Promise(function(resolve, reject) {
    let data = "一些数据";
    //做一些异步操作
    setTimeout(function() {
      console.log("执行完成");
      resolve(data);
    }, 2000);
  });
  return p;
}
runAsync().then(data => {
  console.log(data);
});
```

> `Promise` 的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用

> 在 `then` 方法中，你也可以直接 `return` 数据而不是 `Promise` 对象，在后面的 `then` 中就可以接收到数据了

## reject

```javascript
function getNumber() {
  var p = new Promise(function(resolve, reject) {
    //做一些异步操作
    setTimeout(function() {
      var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
      if (num <= 5) {
        resolve(num);
      } else {
        reject("数字太大了");
      }
    }, 2000);
  });
  return p;
}

getNumber().then(
  function(data) {
    console.log("resolved");
    console.log(data);
  },
  function(reason, data) {
    console.log("rejected");
    console.log(reason);
  }
);
```

## `.catch()`

和 `then` 的第二个参数一样，用来指定 `reject` 的回调

比如：

```javascript
var promise = new Promise(
  (res,
  rej => {
    try {
      throw new Error("error test");
    } catch (error) {
      reject(error);
    }
  })
);
promise.catch(error => {
  console.log(error);
});
```

就和下面的写法是一个效果：

```javascript
var promise = new Promise(
  (res,
  rej => {
    reject(new Error("error test"));
  })
);
promise.catch(error => {
  console.log(error);
});
```

不在执行 `resolve` 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常，那么并不会报错卡死 js，而是会进到这个 `catch` 方法中

`reject()` 方法仅仅抛出错误，如果没有指定 `then` 的 `reject`回调，或者外挂 `.catch()`方法去捕获，那外面对抛出的错误还是没有反应

## all

```javascript
var p = new Promise.all([p1, p2, p3]);
```

可以将多个 `Promise` 实例包装成一个新的 `Promise` 实例

`all` 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调

`all` 接收一个数组参数，里面的值最终都算返回 `Promise` 对象

`all` 会把所有异步操作的结果放进一个数组中传给 `then`

```js
Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results) {
  console.log(results);
});
```

## race

> `all` 方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是 `race` 方法

```javascript
Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results) {
  console.log(results);
});
```

可以用 `race` 给某个异步请求设置超时时间，并且在超时后执行相应的操作

```javascript
//请求某个图片资源
function requestImg() {
  var p = new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      resolve(img);
    };
    img.src = "xxxxxx";
  });
  return p;
}

//延时函数，用于给请求计时
function timeout() {
  var p = new Promise(function(resolve, reject) {
    setTimeout(function() {
      reject("图片请求超时");
    }, 5000);
  });
  return p;
}

Promise.race([requestImg(), timeout()])
  .then(function(results) {
    console.log(results);
  })
  .catch(function(reason) {
    console.log(reason);
  });
```

## 总结一下

- 无法取消 `Promise` ，一旦新建则立刻执行，无法中途取消，**如果不设置回调函数，则 `Promise`内部抛出的错误就不会反应到外部**
- `then` 指定的回调函数将在当前脚本所有同步任务执行完成后进行
- `then` 返回一个**新的 `Promise` 实例，不是原来那个 `Promise`实例**
- `resolve()`函数将把 `Promise` 状态从 `pending ——> fulfiled` 并将异步操作的结果作为参数传出去
- `resolve()`函数的参数还可以是另外一个 `Promise` 实例
- 一般来说，调用 `resolve() 或者`reject()`以后`Promise`的任务就完成了，后续操作应该放在`then`里面，而不是放在`resolve`或者`reject` 的后面
- `then`指定的方法报错也会被 `catch` 方法捕获
- 如果状态已经变成 `Resolved`，那么再抛出错误也无效( `Promise` 的状态一旦改变，就永久保持 )
- `reject()` 方法仅仅抛出错误，如果没有指定 `then` 的 `reject`回调，或者外挂 `.catch()`方法去捕获，那外面对抛出的错误还是没有反应
- `Promise`对象的错误具有 `冒泡` 性质，会一直向后传递，直到被捕获为止，所以可以用一个 `.catch()` 去捕获多个错误
- `.catch()`方法返回的也是一个 `Promise` 对象，因此后面可以继续用 `then`
- `.all()` 和 `.race()` 如果参数不是 `Promise` 对象实例，则会**先调用 `Promise.resolve()` 将对象转换为 `Promise`对象再去处理**

# Iterator

遍历器本质上就是一个指针对象

每次调用 `next` 方法会返回一个包括 `value` 和 `done` 两个属性的对象，即数据结构的当前成员的信息，

`ES6`规定，默认的 `Iterator` 接口部署在数据结构的 `Symbal.iterator` 属性，即一个数据结构只要有`Symbal.iterator` 属性，就认为它是可遍历的（ `iterable` ）

`Symbal.iterator` 本身是一个表达式，返回 `Symbal`对象的 `iterator` 属性， 是预定义好的类型为 `Symbal` 的特殊值，所以放在 `[]`中

`Object` 没有默认部署 `iterator` 接口

## 部署 Iterator 接口

1. 借用
   `Nodelist.prototype[Symbal.iterator] = [][Symbal.iterator]`

2.

## `for...of`

可以使用的范围包括：数组，Set，Map 结构，类数组比如 arguments 对象、DOM Nodelist 对象，Generator 对象，字符串
`for...of`内部调用的是 `Symbal.iterator` 方法

### 对象借用 `for...of`

```javascript
for (var key of Object.keys(target)) {
  console.log(key, target(key));
}
```

# `Generator` 函数

是 `ES6` 提供的一种异步编程解决方案，封装了多个内部状态

执行 `Generator` 函数会返回一个 **遍历器对象**，即`Generator` 函数除了是状态机，还是一个遍历器对象生成函数

`Generator` 函数执行后返回的不是函数运行结果，而是一个指向内部状态的指针对象（Iterator Object）

`Generator` 函数不能跟 `new` 一起使用，否则将报错

`yeild`语句暂停执行， `next`方法恢复执行

遇到 `yeild` 语句就暂停执行后面的操作，并将跟在 `yeild` 后的**表达式的值**作为返回的对象的 `value` 属性值

`yeild` 表达式只能在`Generator` 函数里面，用在其他对方都会报错，如果用在另一个表达式里面，必须放在 `()` 中：

```javascript
function* ge() {
  console.log("hello" + (yield 123));
}
```

## 和 `Symbal.iterator`

`Generator` 函数就是遍历器生成函数，所以可以直接把 `Generator` 赋给对象的 `Symbal.iterator` 属性，使得对象具有 `Iterator` 接口：

```javascript
var obj = {};
obj[Symbal.iterator] = function*() {
  yield 1;
};
```

## `.next(param)`

`Generator` 函数从暂停状态到恢复运行，上下文环境是不变的，但通过 `next()` 方法的参数就可以在`Generator` 函数运行后继续向函数内部注入值，从而调整函数行为

`next()`的参数表示的是上一条`yeild`语句的返回值

## 和`for...of`

**`for...of`循环可以自动遍历`Generator` 函数生成的 `Iterator` 对象，并且不需要再调用一次`next()`启动**

## `.throw(param)`

通过 `.throw()` 在函数体外抛出错误，然后在`Generator` 函数体内捕获

```javascript
var g = function*() {
  try {
    yield;
  } catch (error) {
    console.log(error);
  }
};

var ge = g();
g.next();
g.throw(new Error("test error"));
```

使用 `throw 命令` 抛出的错误，只能在函数体外用 `catch` 语句捕获

如果`Generator` 函数内部没有部署`try...catch`，那么 `.throw()` 方法抛出的错误会被外部 `try...catch` 代码块捕获

如果`Generator` 函数内部署了 `try...catch`，那么遍历器的 `thorw` 方法抛出错误不影响下一次遍历，否则遍历将终止

`.throw()`被捕获以后会 **附带执行下一条`yeild`表达式，即附带执行一个`next()`**

`Generator` 函数执行过程中抛出错误，就不会再执行下去了，后续再调用`next()`，都会返回一个 `value=undefined`，`done=true`的对象

## `.return(param)`

返回参数值并结束`Generator` 函数的遍历

## `yield*`语句

`yield*`后面的`Generator` 函数相当于在`Generator` 函数内部部署一个 `for...of`循环

任何数据结构只要有 `Iterator` 接口,就可以被 `yield*` 遍历：

```javascript
```

有些很好用的途径，比如，拿出来嵌套数组的成员：

```javascript
function* iterTree(tree) {
  if (Array.isArray(tree)) {
    for (let i = 0; i < tree.length; i++) {
      yield* iterTree(tree[i]);
    }
  } else {
    yield tree;
  }
}
const tree = [1, [1, 2, 3], 1];
for (const x of iterTree(tree)) {
  console.log(x);
}
```

## 处理异步

比如处理 `Ajax`：

```javascript
function* main() {
  var request = yield request("url");
  var resp = JSON.parse(result);
  console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, res => {
    it.next(res);
  });
}

var it = main();
it.next();
```

## 控制流

### 同步依次执行

比如**依次执行多个同步任务**：

利用 `for...of` 自动执行 `yield` 命令的特性

```javascript
let steps = [fn1, fn2, fn3];

function* iterateSteps(steps) {
  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];
    yield step();
  }
}
// 还可以分的更细
let jobs = [job1, job2];
function* iterateJobs(jobs) {
  for (let i = 0; i < jobs.length; i++) {
    const element = jobs[i];
    yield* iterateSteps(job.steps);
  }
}
// 最后 一次性全部执行
for (const step of iterateJobs(jobs)) {
  console.log(step.id);
}
```

这个只能执行同步任务，因为一旦得到返回值就继续往下，没有判断异步何时完成

### 异步依次执行

考虑一个问题，`Node`的回调第一个参数都是 `err`，why？

因为执行分为两段，第一段执行完，任务所在的 `context` 已经结束了，在这以后抛出的错误，原来的 `context` 都无法捕获，所以只能当参数传入第二段

## 部署 `Iterate` 接口

# `async` `await`

就是`Generator` 函数的语法糖

- `async` 可以看成由多个异步操作包装成一个 `Promise` 对象
- `await` 命令就是内部 `then` 命令的语法糖

**`async`函数返回一个 `Promise` 对象**，可以继续用 `then` 方法添加回调函数，一旦遇到 `await` 就会先返回，异步操作完成，再继续执行函数体内后面的语句：

```javascript
async function timeout(ms) {
  await new Promise(res => {
    setTimeout(res, ms);
  });
}
async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}
```

**`async` 函数内部 `return` 语句返回的值会成为 `then` 方法回调函数的参数**

**`async` 函数内部抛出的错误对象可以被 `then`的 `catch` 回调捕捉到，且使得返回的 `Promise` 对象状态变为 `rejected`**， `await`后面的`Promise` 对象如果 `rejected`，也会被后面的

`async` **返回的 `Promise` 对象** 会等到所有 `await` 后面的 `Promise` 对象全部执行完才改变最终状态，除非遇到 `return` 或者抛出错误

## `await`

- 如果 `await` 后面不是一个 `Promise` 对象，则会被转成一个立即 `resolve` 的`Promise` 对象
- `await` 抛出的错误，只能被后面的 `catch` 方法捕捉，不能被 `then` 的第二个回调捕捉
- 只要有一个 `await` 后面的`Promise` 对象变为 `rejected` ，那么整个 `async` 函数都会中断执行，想避免的话，要么在把 `await` 放到 `try...catch` 中，要么在一个`await`后面跟一个 `catch` 方法来捕捉错误
- `await` 后面的异步出错，等同于 `async` 函数返回的 `Promise` 对象被 `rejected`

### 最佳实践

1. `await` 后面的`Promise`运行有可能`rejected`，所以最好放在 `try...catch` 中，而且多个 `await` 可以放到一个里面
2. 多个 `await` 后面的异步操作如果不存在继发关系，最好让他们同时发生，缩短程序执行时间：
   ```javascript
   let foo = await getFoo();
   let bar = await getBar();
   //改成这样子
   let [foo, bar] = await Promise.all([getFoo(), getBar()]);
   ```
3. 多个请求并发，要么 `Promise.all`，要么 `for` 里面函数加 `await`：

   ```javascript
   async function dbFun(db) {
     let docs = [{}, {}, {}];
     let promises = docs.map(doc => db.post(doc));

     let results = await Promise.all(promises);
     return results;
   }
   ```

## `async` 原理

就是将 `Generator` 函数和自动执行器包装在一个函数里

```javascript
async function fn(args) {}
// 相当于
function fn(args) {
  return spawn(function*() {});
}
```

而 `spawn()` 的实现：

```javascript
function spawn(genF) {
  return new Promise(function(resolve, rekect) {
    var gen = genF();
    function step(nextF) {
      try {
        var next = nextF();
      } catch (e) {
        return reject(e);
      }

      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function(v) {
          step(function() {
            return gen.next(v);
          });
        },
        function(e) {
          step(function() {
            return gen.throw(e);
          });
        }
      );
    }
    step(function() {
      return gen.next(undefined);
    });
  });
}
```

# class

## 定义一个类

两种方法：

- 类声明：使用 `class` 关键字
- 类表达式：

```javascript
//匿名类。。。
let Rectangle = class {...}

let Rectangle = class Rectangle {...}
```

- **不会提升**

- `constructor` 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。

- 一个类必须有 `constructor` 方法，如果没有显式定义，一个空的 `constructor` 方法会被默认添加。

- `constructor` 方法默认返回实例对象（`this`），完全可以指定返回另外一个对象。

* 定义“类”的方法的时候，前面不需要加上 `function` 关键字

* **方法之间不需要逗号分隔**

* 当一个对象调用静态或原型方法时，如果该对象没有 `this` 值 ，那么“this”值在被调用的函数内部将为 `undefined` 。不会发生自动包装。

* 类的所有方法都定义在类的 `prototype` 属性上面

* 类的内部所有定义的方法，都是不可枚举的（`non-enumerable`）

* 在 `class` 中。同时具有 `__proto__` 和 `prototype` 两个属性，存在两条继承链。

* 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类。

* 子类的 prototype 的 `__proto__` 属性表示方法的继承，总是指向父类的 `prototype` 属性。

## 私有方法

也没提供私有方法，而且**模块内部的所有方法都是对外可见**，所以可以这样子移出去：

```javascript
class Widget {
  foo(baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return (this.snaf = baz);
}
```

或者使用 `Symbol` 值的唯一性，将私有方法的名字命名为一个 `Symbol` 值。

```javascript
const bar = Symbol("bar");
const snaf = Symbol("snaf");

export default class myClass {
  // 公有方法
  foo(baz) {
    this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
    return (this[snaf] = baz);
  }

  // ...
}
```

## static

类相当于实例的原型，所有在类中定义的方法，都会被实例继承

如果在一个方法前，加上 `static` 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

```javascript
class Foo {
  static classMethod() {
    return "hello";
  }
}

Foo.classMethod(); // 'hello'

var foo = new Foo();
foo.classMethod();
// TypeError: foo.classMethod is not a function
```

- 父类的静态方法，可以被子类继承。
- 静态方法也是可以从 `super` 对象上调用的。

## 继承

`class ColorPoint extends Point {}`

子类必须在 `constructor` 方法中调用 `super` 方法，否则新建实例时会报错。这是因为子类没有自己的 `this` 对象，而是继承父类的 `this` 对象

### super
*`es6` 要求，子类的构造函数内部必须执行一次 `super` 函数*
`super` 关键字表示父类的构造函数，用来新建父类的 `this` 对象

`super` 虽然代表了父类的构造函数，但是返回的是子类的实例，即 `super` 内部的 `this` 指的是，因此 `super()` 在这里相当于 `Father.prototype.constructor.call(this, props)`

两种用法：

- 在`constructor` 当函数使用
- 当普通方法中，指向父类的原型对象；在静态方法中，指向父类。

```javascript
class A {
  c() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}

let b = new B();
```

**通过 super 调用父类的方法时，super 会绑定子类的 this。**

```javascript
class A {
  constructor {
    this.x = 1;
  }
  s() {
    console.log(this.x);
  }
}

class B extends A {
  constructor {
    super();
    this.x = 2;
  }
  m() {
    super.s();
  }
}

let b = new B();
b.m(); // 2
```

由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性：

```javascript
class A {
  constructor {
    this.x = 1;
  }
}

class B extends A {
  constructor {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```

摘自：https://www.jianshu.com/p/fc79756b1dc0

# Object

允许对象字面量时也使用表达式作为属性名

```javascript
var lastWord = "last word";

var a = {
  "first word": "hello",
  [lastWord]: "world"
};
```

# Notes

要给函数传进去对象参数，且对象参数有默认值，可以结合用 `解构赋值`和 `默认参数` 来实现：

```javascript
function desc({ name = "fyg", age = 26, career = "FrontEnd" } = {}) {
  console.log(name, age, career);
}
desc({
  career: "后台"
});
```
