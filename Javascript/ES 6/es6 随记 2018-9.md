# promise

首先，无法取消 `Promise` ，一旦新建则立刻执行，无法中途取消，**如果不设置回调函数，则 `Promise`内部抛出的错误就不会反应到外部**

Promise的构造函数接收一个函数作为参数，这个函数有两个参数（同样是函数）： `resolve` ， `reject` ，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的`回调函数`


## then resolve
`Promise`实例生成以后，可以使用 `then` 方法来指定 `Resolve`（即从 `Pending` 状态变为 `Fullfiled`状态）和 `Rejected`（`Pending` -> `Rejected`）状态时的函数，其中， `Rejected` 是可选的


**`Promise`新建后会立刻执行， `then` 方法指定的回调函数将在所有同步任务执行完以后才执行**


比如：
```javascript
function runAsync() {
    var p = new Promise(function (resolve, reject) {
        let data = "一些数据";
        //做一些异步操作
        setTimeout(function () {
            console.log('执行完成');
            resolve(data);
        }, 2000);
    });
    return p;
}
runAsync().then(data => {
 console.log(data);
})

```

> `Promise` 的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用

> 在 `then` 方法中，你也可以直接 `return` 数据而不是 `Promise` 对象，在后面的 `then` 中就可以接收到数据了

## reject
```javascript
function getNumber(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
        }, 2000);
    });
    return p;            
}

getNumber()
.then(
    function(data){
        console.log('resolved');
        console.log(data);
    }, 
    function(reason, data){
        console.log('rejected');
        console.log(reason);
    }
);
```

## catch
和 `then` 的第二个参数一样，用来指定 `reject` 的回调

不在执行 `resolve` 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常，那么并不会报错卡死js，而是会进到这个 `catch` 方法中

## all

`all` 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调

`all` 接收一个数组参数，里面的值最终都算返回 `Promise` 对象

`all` 会把所有异步操作的结果放进一个数组中传给 `then`

```js
Promise
.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
```

## race
> `all` 方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是 `race` 方法
```javascript
Promise
.race([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
```
可以用 `race` 给某个异步请求设置超时时间，并且在超时后执行相应的操作
```javascript
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = 'xxxxxx';
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
```

## Catch Error




# class
## 定义一个类
两种方法：
- 类声明：使用 `class` 关键字
- 类表达式：
```javascript
//匿名类。。。
let Rectangle = class {...}

let Rectangle = class Rectangle {...}
```

- **不会提升**

- `constructor` 方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。

- 一个类必须有 `constructor` 方法，如果没有显式定义，一个空的 `constructor` 方法会被默认添加。

- `constructor` 方法默认返回实例对象（`this`），完全可以指定返回另外一个对象。


- 定义“类”的方法的时候，前面不需要加上 `function` 关键字

- **方法之间不需要逗号分隔**

- 当一个对象调用静态或原型方法时，如果该对象没有 `this` 值 ，那么“this”值在被调用的函数内部将为 `undefined` 。不会发生自动包装。

- 类的所有方法都定义在类的 `prototype` 属性上面

- 类的内部所有定义的方法，都是不可枚举的（`non-enumerable`）

- 在 `class` 中。同时具有 `__proto__` 和 `prototype` 两个属性，存在两条继承链。

- 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类。

- 子类的 prototype 的 `__proto__` 属性表示方法的继承，总是指向父类的 `prototype` 属性。

## 私有方法
也没提供私有方法，而且**模块内部的所有方法都是对外可见**，所以可以这样子移出去：
```javascript
class Widget {
  foo (baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}
```
或者使用 `Symbol` 值的唯一性，将私有方法的名字命名为一个 `Symbol` 值。
```javascript
const bar = Symbol('bar');
const snaf = Symbol('snaf');

export default class myClass{

  // 公有方法
  foo(baz) {
    this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }

  // ...
};
```
## static
类相当于实例的原型，所有在类中定义的方法，都会被实例继承

如果在一个方法前，加上 `static` 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

```javascript
class Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
```

- 父类的静态方法，可以被子类继承。
- 静态方法也是可以从 `super` 对象上调用的。


## 继承
`class ColorPoint extends Point {}`

子类必须在 `constructor` 方法中调用 `super` 方法，否则新建实例时会报错。这是因为子类没有自己的 `this` 对象，而是继承父类的 `this` 对象

### super
`super` 关键字表示父类的构造函数，用来新建父类的 `this` 对象

`super` 虽然代表了父类的构造函数，但是返回的是子类的实例，即 `super` 内部的 `this` 指的是，因此 `super()` 在这里相当于 `Father.prototype.constructor.call(this, props)`

两种用法：
- 在`constructor` 当函数使用
- 当普通方法中，指向父类的原型对象；在静态方法中，指向父类。

```javascript
class A {
  c() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}

let b = new B();

```
**通过 super 调用父类的方法时，super 会绑定子类的 this。**

```javascript
class A {
  constructor {
    this.x = 1;
  }
  s() {
    console.log(this.x);
  }
}

class B extends A {
  constructor {
    super();
    this.x = 2;
  }
  m() {
    super.s();
  }
}

let b = new B();
b.m(); // 2
```

由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性：
```javascript
class A {
  constructor {
    this.x = 1;
  }
}

class B extends A {
  constructor {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```

摘自：https://www.jianshu.com/p/fc79756b1dc0

# Object
允许对象字面量时也使用表达式作为属性名

```javascript
var lastWord = 'last word';

var a = {
  'first word': 'hello',
  [lastWord]: 'world'
};
```


# Generator
<slot>

</slot>
# Notes
要给函数传进去对象参数，且对象参数有默认值，可以结合用 `解构赋值`和 `默认参数` 来实现：
```javascript
function desc ({name = 'fyg',age = 26, career="FrontEnd"} = {}) {
    console.log(name,age,career);
}
desc({
    career:"后台"
})
```


