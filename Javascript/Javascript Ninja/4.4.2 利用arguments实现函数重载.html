<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>函数重载</title>
</head>

<body>


    <script>
        function merge (root) {
            console.log(root);
            // 将参数列表中从第二项开始的对象都合并到第一项中去
            // 所以，索引从 1 开始
            for (let index = 1; index < arguments.length; index++) {
                for (const key in arguments[index]) {
                    if (arguments[index].hasOwnProperty(key)) {
                        // 而 root ，只是第一个参数（对象），所以，这里 root[key] 会给第一个参数添加新的 key ，并且 这个 key 的 value 为arguments[index][key]
                        root[key] = arguments[index][key];
                    }
                }
            }

            return root
        }

        var merged = merge(
            {name:"fyg"},
            {age:"25",career:"jser"}
        )

        document.write(JSON.stringify(merged))


        //  对 arguments 列表进行 slice 和 disc
        // 即 还是应用伪装数组方法
        function multiMax (multi) {
            return muitl * Math.max.apply(Math, [].slice.call(arguments, 1))
        }



        /*
         *函数重载
        */
        function addMethod (obj, name, fn) {
            var old = obj[name];
            obj[name] = function () {
                // 每次存进去的都是这个匿名函数，而新写的函数只是被当成了一个参数！
                if (fn.length == arguments.length) {
                    // 这个 arguments.length 是 obj[name] 的，而不是外面那个 addMethod 的
                    return fn.apply(this, arguments)
                }else{
                    return old.apply(this, arguments)
                }
            }
            // console.log(old);
        }
        // 使用

        var ninja = {
            values:["html", "css", "javascript", "feng yanggang"]
        }

        addMethod(ninja, "find", function () {
        // 第一个传进去的函数
            return this.values
        });
        console.log(ninja);
        addMethod(ninja, "find", function ( name ) {
            var ret = [];
            for (let i = 0; i < this.values.length; i++) {
                if (this.values[i].indexOf(name) == 0) {
                    ret.push(this.values[i]);
                }
            }
            return ret;
        });
        // 到这里时候，ninja的find上存的是 上面obj[name]那个原来的函数, find 的闭包里面存了 fn 和 old， fn 里面存的是 f(name)，old里面是 obj[name],
        // old 的闭包里面存了 第一次传进去的函数
        console.log(ninja);
        addMethod(ninja, "find", function ( first, last ) {
            var ret = [];
            for (let i = 0; i < this.values.length; i++) {
                if (this.values[i] == (first + " " + last)) {
                    ret.push(this.values[i]);
                }
            }
            return ret;
        });
        
        console.log(ninja);
        // 到这里时候，ninja的find上存的是 上面obj[name]那个原来的函数, find 的闭包里面存了 fn 和 old， fn 里面存的是 f(first, last)，old 里面继续是 obj[name],
        // old 的闭包里面存了 第二次传进去的函数即 fn(name) 和 old (obj[name]) ，这里套的这个old的闭包里面才是第一次的f() 和 old (undefined)
        console.log(ninja.find());
        console.log(ninja.find("css"));
        console.log(ninja.find("feng","yanggang"));


        function argTest (argument1, argument2) {
            console.log(`实参 arguments.length :${arguments.length} `);
            console.log(`arguments: ${argument1}, ${argument2}`);
            console.log(`形参 parameter  function.length - argTest.length:${argTest.length} `);
        }
        argTest("a")
    </script>
</body>

</html>