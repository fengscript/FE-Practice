<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>


 <script>
    //  构造函数继承
    function SuperClass (id) {
        // 引用类型共有属性
        this.books = ['javascript','css','html'];
        
        // 值类型共有属性
        this.id = id;
    }

    // 增强父类
    SuperClass.prototype.showBooks = function () {
        console.log(this.books)
    }


    // 子类
    function SubClass (id) {
        // 继承
        SuperClass.call(this, id);  // call改变了函数的作用环境，即，将子类中的变量 id 在父类中执行了一遍，由于父类中的属性是绑定在 this 上的，因此子类也继承了父类的共有属性。
        //由于没有涉及原型，所以父类的原型方法不会被子类继承。 若想被子类继承，就要将原型方法放在构造函数中，这样创建出来的每个实例都会单独拥有一份方法而不能共用，违背了代码复用的原则，所以后面有了组合继承。
    };

    // 实例化一个
    var instance1 = new SubClass(2);
    var instance2 = new SubClass(6);

    instance1.books.push("设计模式");//此时，引用值类型的操作不会互相影响了
    
    console.log(instance1.books);
    console.log(instance1.id);
    

    console.log(instance2.books);
    console.log(instance2.id);
 </script>
</body>

</html>