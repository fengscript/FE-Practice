为什么使用动态原型模式：

1 原型中的所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个对象，如果一个对象对原型的属性进行了修改，则会反映到所有的对象上面。

但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。但是，这个共享特性对 方法(属性值是函数的属性)又是非常合适的

2 在构造函数中添加的属性和方法，每个对象都有自己独有的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。

3 所以使用组合构造函数模式和原型模式来取他们所有的优点
```JS
//在构造方法内部封装属性
function Person(name, age) {
    this.name = name;
    this.age = age;
}
//在原型对象内封装方法
Person.prototype.eat = function (food) {
    alert(this.name + "爱吃" + food);
}
Person.prototype.play = function (playName) {
    alert(this.name + "爱玩" + playName);
}
```

 4 把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。

动态原型模式是将所有的信息都封装在了构造函数中，在构造函数初始化原型（必要的情况下），保持了同时使用构造函数和原型模式的优点。

可以通过检查某个应该存在的方法时候有效来决定是否需要初始化原型。

```js
function Person (name,age) {
    this.name = name,
    this.age = age

    //methods
    if (typeof this.sayName != "function" ) {
        Person.prototype.sayName = function () {
            document.write(this.name)
        };
    }
}
var friend = new Person('fyg',24)
friend.sayName()
```

此处，原型上的方法只有在它不存在的情况下才会被添加，只有初次调用构造函数时会执行，之后，原型完成了初始化，不需要再做修改。

又因为，对原型做的任何修改，都可以立即在实例中得到反映，因此，这里添加的方法也会在实例中立即调用。

动态原型模式不能使用对象字面量重写原型，在已经建立了实例的情况下重写原型，会切断实例和新原型之间的联系。

**对象中的同名属性，会屏蔽原型上的同名属性**